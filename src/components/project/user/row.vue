<!--
Copyright 2017 ODK Central Developers
See the NOTICE file at the top-level directory of this distribution and at
https://github.com/getodk/central-frontend/blob/master/NOTICE.

This file is part of ODK Central. It is subject to the license terms in
the LICENSE file found in the top-level directory of this distribution and at
https://www.apache.org/licenses/LICENSE-2.0. No part of ODK Central,
including this file, may be copied, modified, propagated, or distributed
except according to the terms contained in the LICENSE file.
-->
<template>
  <tr>
    <td class="display-name">
      <span :title="actor.displayName">{{ actor.displayName }}</span>
    </td>
    <td>
      <form>
        <div class="form-group">
          <select class="form-control" :value="selectedRole"
            :disabled="disabled || awaitingResponse"
            :title="disabled ? $t('cannotAssignRole') : null"
            :aria-label="$t('field.projectRole')"
            @change="change($event.target.value)">
            <option v-for="role of projectRoles" :key="role.id"
              :value="role.system">
              {{ $t(`role.${role.system}`) }}
            </option>
            <option value="">{{ $t('role.none') }}</option>
          </select>
          <span class="spinner-container">
            <spinner :state="awaitingResponse"/>
          </span>
        </div>
      </form>
    </td>
  </tr>
</template>

<script>
import Spinner from '../../spinner.vue';

import { apiPaths } from '../../../util/request';
import { mixinRequests } from '../../../reusables/requests';
import { noop } from '../../../util/util';
import { requestDataComputed } from '../../../reusables/request-data';

export default {
  name: 'ProjectUserRow',
  components: { Spinner },
  mixins: [mixinRequests],
  inject: ['requestData'],
  props: {
    assignment: {
      type: Object,
      required: true
    }
  },
  emits: ['change'],
  data() {
    return {
      awaitingResponse: false,
      selectedRole: this.assignment.roleId != null
        ? this.requestData.roles.data.get(this.assignment.roleId).system
        : ''
    };
  },
  computed: {
    ...requestDataComputed({
      currentUser: ({ currentUser }) => currentUser.data,
      rolesBySystem: ({ roles }) => roles.bySystem,
      projectRoles: ({ roles }) => roles.projectRoles,
      project: ({ project }) => project.data
    }),
    actor() {
      return this.assignment.actor;
    },
    disabled() {
      return this.actor.id === this.currentUser.id;
    }
  },
  methods: {
    async revoke(system, signal) {
      if (system === '') return;
      const roleId = this.rolesBySystem.get(system).id;
      await this.request({
        method: 'DELETE',
        url: apiPaths.projectAssignment(this.project.id, roleId, this.actor.id),
        signal
      });
      this.requestData.projectAssignments.revoke(this.actor.id);
    },
    async assign(system, signal) {
      if (system === '') return;
      const roleId = this.rolesBySystem.get(system).id;
      await this.request({
        method: 'POST',
        url: apiPaths.projectAssignment(this.project.id, roleId, this.actor.id),
        signal
      });
      this.requestData.projectAssignments.assign(this.actor, roleId);
    },
    change(selectedRole) {
      const oldRole = this.selectedRole;
      this.selectedRole = selectedRole;

      const abortController = new AbortController();
      const unwatch = this.$watch(this.requestData.projectAssignments.ref, () => {
        abortController.abort();
        unwatch();
      });

      // At some point we may implement something transactional so that we don't
      // need to send two requests.
      this.revoke(oldRole, abortController.signal)
        .then(() => this.assign(selectedRole, abortController.signal)
          .catch(error => {
            if (oldRole !== '' && error.response != null) {
              this.selectedRole = '';
              this.requestData.projectAssignments.revoke(this.actor.id);
              this.$emit('change', this.actor, '', true);
            }
            throw error;
          }))
        .then(() => {
          this.$emit('change', this.actor, selectedRole, false);
        })
        .finally(unwatch)
        .catch(noop);
    }
  }
};
</script>

<style lang="scss">
#project-user-list td {
  vertical-align: middle;

  &.display-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .form-group {
    margin-bottom: 0;
    padding-bottom: 0;
  }

  .form-control {
    display: inline-block;
    width: 215px;
  }

  .spinner-container {
    margin-left: 15px;
    // Spinner is positioned absolutely.
    position: relative;
  }
}
</style>

<i18n lang="json5">
{
  "en": {
    "cannotAssignRole": "You may not edit your own Project Role.",
    "field": {
      "projectRole": "Project Role"
    }
  }
}
</i18n>

<!-- Autogenerated by destructure.js -->
<i18n>
{
  "cs": {
    "cannotAssignRole": "Nemůžete upravovat svou vlastní roli projektu.",
    "field": {
      "projectRole": "Role projektu"
    }
  },
  "de": {
    "cannotAssignRole": "Sie dürfen Ihre eigene Projektrolle nicht bearbeiten.",
    "field": {
      "projectRole": "Projektrolle"
    }
  },
  "es": {
    "cannotAssignRole": "No puede editar su propio rol en el proyecto",
    "field": {
      "projectRole": "Rol en el proyecto"
    }
  },
  "fr": {
    "cannotAssignRole": "Vous ne pouvez pas modifier votre propre rôle dans le projet.",
    "field": {
      "projectRole": "Rôle dans le projet"
    }
  },
  "id": {
    "cannotAssignRole": "Anda tidak dapat mengubah Peran Proyek Anda sendiri.",
    "field": {
      "projectRole": "Peran Proyek"
    }
  },
  "it": {
    "cannotAssignRole": "Non puoi modificare il tuo ruolo nel progetto.",
    "field": {
      "projectRole": "Ruolo del progetto"
    }
  },
  "ja": {
    "cannotAssignRole": "自分自身のプロジェクトの役割を変更することはできません。",
    "field": {
      "projectRole": "プロジェクトでの役割"
    }
  }
}
</i18n>
